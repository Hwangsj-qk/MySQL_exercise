## 인덱스(Index)
- DB에서 검색을 빠르게 하기 위해 사용되는 데이터 구조
- 하나 이상의 컬럼(속성)에 해당 열을 기준으로 데이터를 빠르게 검색
- 일반적으로 B-Tree 데이터 구조를 사용 
- 성능 최적화, 쿼리 최적화
    - 실제 데이터베이스에서 인덱스 튜닝을 하면 즉각적으로 성능 효과를 보고, 빠른 응답속도를 얻어낼 수 있음.
- 인덱스 생성, 유지 관리에 자원이 소모되어
    - 데이터 조작 작업(INSERT, UPDATE, DELETE) 작업 시 추가 작업이 필요함
    - 데이터가 변경될 때마다 인덱스도 변경되어야 함
    - 조작(쓰기) 작업이 많은 DB에서는 오히려 인덱스의 성능이 감소

### 클러스터형 인덱스와 보조 인덱스
1. 클러스터 인덱스 (Clustered Index)
   - 테이블 생성 시 **기본 키**를 지정하면 기본키에 대한 클러스터 인덱스를 생성
   - <u>**물리적 데이터베이스**</u>가 클러스터 인덱스를 기준으로 <u>정렬</u>되어 저장됨.
   - <u>**한 테이블 당 하나**</u>만 생성할 수 있음.
2. 보조 인덱스 (Secondary Index)
   - 데이터의 물리적 정렬 순서를 변경하지 않음.
   - 클러스터 인덱스와는 별개로 하나 이상의 컬럼에 대한 **참조 인덱스** 제공
   - 데이터에 포인터를 사용해서 간접적으로 접근
   - 하나의 테이블에는 여러개의 보조인덱스가 존재할 수 있음. 
> 클러스터 인덱스 : 영어사전 vs. 보조 인덱스 : 책의 <찾아보기>   
    
### MySQL에서 자동으로 생성되는 인덱스
   - 기본 키 인덱스
      - 테이블의 고유 식별, 클러스터 인덱스가 생성
   - 외래 키 인덱스
      - 외래 키 제약조건이 있는 컬럼을 기준
      - 참조 무결성, 조인 연산 속도 향상을 위해 자동 생성
   - 유니크 인덱스 
      - 고유 제약 조건을 설정하면 자동으로 인덱스 생성

1. PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성
2. UNIQUE NOT NULL 지정한 열은 클러스터형 인덱스가 생성 
   - primary key가 있다면 primary key가 우선
3. UNIQUE 지정한 열은 보조 인덱스가 생성
4. FOREIGN KEY 지정한 열은 보조 인덱스가 생성
5. PRIMARY KEY와  UNIQUE NOT NULL 지정한 열이 있으면 기본 키 지정한 열에 우선하여 클러스터형 인덱스 생성
6. 물리적 DB는 PRIMARY KEY 지정한 열로 데이터 오름차순 정렬 

### 인덱스의 내부작동 BTREE
- 데이터베이스 테이블을 효율적으로 관리하는 인덱스 자료구조

- 기본 개념 정의
1. 노드(Node) : 트리의 기본 단위 (트리구조에서 데이터가 존재하는 공간)
2. key : 노드 내에서 데이터를 정렬하는데 사용되는 요소
3. 루트 노드(Root Node) : 트리의 최상위 노드
4. 리프 노드(Leaf Node) : 트리의 가장 하단에 위치하는 노드들, 실제 데이터의 주소나 데이터 자체를 포함할 수 있음.  
5. 내부 노드 (Internal Node) : 루트 노드와 리프 노드 사이에 있는 노드 (= 중간수준노드)
- ![B-tree 그림](2024-04-18-10-53-28.png)

- B Tree의 파라미터
   1. M : 각 노드의 최대 자녀수(최대 M개의 자녀를 가질 수 있는 M차 B tree)
   2. M-1 : 각 노드의 최대 키 수 

- 이터널 노드의 key 수가 x개라면 자녀 노드 수는 언제나 x+1개
- 몇 차 B Tree의 별개로 인터널 노드는 반드시 최소 2개의 자녀를 가진다. 
- 삽입은 항상 Leaf 노드에 한다.
- 노드가 넘치면 가운데 key 기준으로 좌우 key를 분할하고 가운데 key 승진

- [B 트리 시각화](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

   - 모든 leaf 노드는 같은 레벨에 존재하게 됨 

- B-Tree의 이점
   - 트리 깊이가 낮다 : 각 노드에서 많은 수의 자식을 가질 수 있기 때문에, 트리 깊이가 낮아짐(트리깊이 = 디스크 접근 횟수)
   - 디스크 I/O 최적화 : 보조기억장치의 디스크 블록 크기와 일치하도록 노드 크기를 설정할 수 있음. 한 번의 읽기/쓰기 노드(페이지) 하나를 전체로 읽거나 쓸 수 있음 
   - 분할 및 병합이 효율적임 : 노드(페이지)가 가득찼을 때 분할하거나 병합될 때 효율적이 알고리즘을 가지고 있음 

### 인덱스 생성, 변경, 삭제
- 인덱스 기본 생성 문법
```sql
   -- 인덱스를 추가할 테이블의 이름과 컬럼 기준으로 인덱스 생성 
   CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼이름);

   -- 복합 인덱스 생성
   CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼이름1, 컬럼이름2, 컬럼이름3, ...);

   -- 고유 인덱스 생성(중복된 값 허용 안되는 인덱스)
   CREATE UNIQUE INDEX 인덱스이름 ON 테이블이름 (컬럼이름);

   -- 인덱스 삭제
   DROP INDEX 인덱스 이름 ON 테이블이름;

   -- 인덱스 정보조회
   SHOW INDEX FROM 테이블명;

   -- 쿼리 실행계획 확인
   EXPLAIN SELECT 컬럼명 FROM 테이블명 WHERE 조건; 

   -- 인덱스 수정
   ALTER INDEX 이전인덱스명 RENAME TO 새인덱스명;

   -- 인덱스 컬럼 추가
  ALTER INDEX 이전인덱스명 ADD 새인덱스명;

  -- 인덱스 컬럼 제거
  ALTER INDEX 이전인덱스명 DROP 새인덱스명;

  -- 테이블 업데이트 및 분석
  ANALYZE TABLE 테이블명;

  -- 테이블 상태 확인하기
   SHOW TABLE STATUS;
   SHOW TABLE STATUS LIKE '테이블명';
```
### 인덱스 성능 향상
1. 인덱스는 열(컬럼) 단위로 생성
2. WHERE 절에서 자주 사용되는 컬럼에 인덱스를 생성
3. 자주 정렬(SORT)되거나 그룹화(GROUP BY)가 필요한 쿼리에 인덱스 생성
4. 다른 테이블과 자주 조인되는 컬럼에 인덱스 사용
5. 특정 범위로 검색하는 쿼리에 인덱스를 사용
6. 특정 범위로 검색하는 쿼리에 인덱스를 사용
7. 사용하지 않는 인덱스는 제거하는 것이 성능 향상
8. 쓰기 작업은 적고, 읽기 작업이 많은 테이블에 인덱스 생성
- 인덱스를 사용하면 성능 향상이 안되는 경우
   1. 데이터가 자주 변경되는 테이블 (쓰기 작업이 많은 테이블)
      - 데이터 변경 작업이 일어날때마다 인덱스들도 같이 변경 작업 필요
   2. 데이터 양이 적은 집합  
      - 데이터가 적을 경우 오히려 성능을 저하시킬 수 있음.
   3. 고유값의 수가 낮은 컬럼
      - 인덱스를 설정해도 거의 효과가 없음.
   4. 쿼리가 대부분의 테이블 데이터를 반환해야 할 경우
      - 전체 데이터를 반환해야 한다면 Full Table Scan이 유리
   5. 데이터 크기가 큰 필드(컬럼) (BLOB, TEXT
      -  크기가 큰 이진파일이나, 내용이 매우 긴 텍스트 인덱스는 비효율            



